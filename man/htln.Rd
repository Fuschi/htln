% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/htln_distribution.R, R/htln_doc.R, R/mle_htln.R
\name{dhtln}
\alias{dhtln}
\alias{qhtln}
\alias{rhtln}
\alias{htln}
\alias{mle_htln}
\title{Hurdle Truncated Log-Normal (HTLN) Family}
\usage{
dhtln(x, phi = 0, meanlog = 0, sdlog = 1, a_log = 0, b_log = Inf)

qhtln(
  p,
  phi = 0,
  meanlog = 0,
  sdlog = 1,
  a_log = 0,
  b_log = Inf,
  integer = TRUE
)

rhtln(
  n,
  phi = 0,
  meanlog = 0,
  sdlog = 1,
  a_log = 0,
  b_log = Inf,
  integer = TRUE
)

mle_htln(
  y,
  b_log = function(z) max(z) + 3 * stats::sd(z),
  optim_method = "BFGS",
  optim_control = list(),
  optim_hessian = FALSE,
  optim_lower = -Inf,
  optim_upper = Inf
)
}
\arguments{
\item{x}{Numeric vector at which to evaluate the density \code{dhtln()}
(values must be on the \eqn{Z = \log(Y+1)} scale).}

\item{phi}{Hurdle probability \eqn{P(Y = 0)}.}

\item{meanlog, sdlog}{Mean and standard deviation of the truncated normal
component on the log1p scale.}

\item{a_log, b_log}{Lower and upper truncation bounds for the truncated normal
component on the log1p scale.}

\item{p}{Numeric vector of probabilities for \code{qhtln()}.}

\item{integer}{Logical. If \code{TRUE} (default), random variates generated by
\code{rhtln()} are returned on the original scale and coerced to integers.}

\item{n}{Integer number of observations to simulate in \code{rhtln()}.}

\item{y}{Numeric vector of non-negative observations (input to
\code{mle_htln()}). Internally transformed via \code{log1p(y)}.}

\item{optim_method, optim_control, optim_hessian, optim_lower, optim_upper}{Optimisation settings used only by \code{mle_htln()} and passed directly
to \code{\link[stats]{optim}} (as \code{method}, \code{control},
\code{hessian}, and box constraints via \code{lower}/\code{upper}).
See \code{\link[stats]{optim}} for details.}
}
\value{
\itemize{
\item \code{mle_htln()} returns an object of class \code{"htln_fit"} with:
\itemize{
\item \code{coef}: named vector with estimates \code{phi},
\code{meanlog}, \code{sdlog}, and \code{b_log};
\item \code{logLik}: the maximised log-likelihood;
\item \code{nobs}: number of observations;
\item \code{optim_trunc}: the \code{optim()} output for the continuous component.
}
\item \code{dhtln()} returns density values for the mixture model:
a point mass \code{phi} at \eqn{Z = 0} and a truncated normal
density for \eqn{Z > 0}.
\item \code{qhtln()} returns quantiles on the original \eqn{Y} scale.
\item \code{rhtln()} generates random samples from the fitted
hurdle truncated log-normal model.
}
}
\description{
Functions to fit, evaluate, and simulate from a hurdle model where the
continuous component follows a truncated normal distribution on the
log-transformed scale \eqn{Z = \log(Y + 1)}.
}
\details{
This model is designed for non-negative data with excess zeros and heavy
right tails—common in microbiome and NGS applications—where the distribution
of strictly positive values is well captured by a truncated normal on the
log1p scale.

The model is:
\deqn{
  P(Y = 0) = \phi, \qquad
  Z = \log(Y+1), \qquad
  Z \mid (Y > 0) \sim \mathrm{TruncNorm}(\mu, \sigma^2; [a_{\log}, b_{\log}]),
}
where:
\itemize{
\item \eqn{\phi} is the hurdle probability (probability of observing a structural zero),
\item \eqn{Z = \log(Y+1)} is truncated to the interval \eqn{[a_{\log}, b_{\log}]},
\item \eqn{\mu} and \eqn{\sigma} are the mean and standard deviation of the
truncated normal on the log scale.
}
}
\section{Fitting}{

\code{mle_htln()} performs maximum likelihood estimation of the hurdle
parameter \eqn{\phi} and the truncated normal parameters \eqn{\mu} and
\eqn{\sigma} using numerical optimisation via \code{\link[stats]{optim}}.

The optimisation step for the continuous component can be tuned via the
arguments \code{optim_method}, \code{optim_control}, \code{optim_hessian},
\code{optim_lower}, and \code{optim_upper}; see \code{\link[stats]{optim}}
for further details on these options.

The upper truncation bound \code{b_log} applies on the log1p scale and can be:
\itemize{
\item a numeric scalar (constant upper bound, possibly \code{Inf});
\item a function of the positive log-values, e.g.
\code{function(z) max(z) + 3 * sd(z)} (default).
}

The function returns an object of class \code{"htln_fit"}, for which S3
generics \code{coef()}, \code{logLik()}, \code{AIC()}, \code{BIC()}, and
\code{nobs()} are implemented.
}

\seealso{
\code{\link[stats]{optim}},
\code{\link[truncnorm]{dtruncnorm}},
\code{\link[truncnorm]{qtruncnorm}},
\code{\link[truncnorm]{rtruncnorm}}
}
